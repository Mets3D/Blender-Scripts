Bone Group System
	First off, we ignore how Rigify does it for now.

	Each rig element defines its own set of bone groups that it uses. These can be customized via rig parameters. You can browse an existing bone group on the metarig to use as the group for the rig element. But they start out pre-initialized, and if their bonegroup doesn't exist, they will be created on generation.
	If they do exist, the colors and active layers can be displayed next to it.
	Different rig elements could define bone groups with the same name - In this case, they will share a bone group.
	Each bone group can be assigned to one or more layers.

	Layers have names, and can be assigned to a row. Same as Rigify. But they can NOT be assigned a bone group!

BBone Face Rig idea:
	What if there are two layers of BBones? One is Automatic, the other is Tangent.
	We then steal the tangents of the Automatic with Copy Transforms constraints that have splining enabled.
	meh, you still need two bones to do translation+rotation separately methinks.
	Control
		Automatic chain
			Automatic angle reader
				Tangent angle (parented)
	In this setup, how do we get the local rotation of Control to affect Tangent angle in a predictable way?

Addon idea:
	Make a better Shift+D (duplicate bone) behaviour, where instead of slamming a .001 at the end of the bone name, it increments whatever number it finds in the bone name, and it does the same on the right side.

Settlers TODO:
	Make cloud posts about phileas face and backpack
	Phileas:
		- Better symmetrical curve support, so mirror posing works.
		- Hook up eye lattice with 3 controls per eye (top middle bottom)
		
	Lunte:
		- Add new masking tech to the teeth, rename bones.
		- Teeth names could use some love, but then gotta run the curve renaming script on everything again.

CloudRig TODO:
	Normal rigs don't seem to get parented to cloud_bone Create rigs. (Phileas backpack)
	Spine fails to generate when IK is turned off? (while working on Phileas, with spine length 4)
	Eye Track
		A rig that sets up an eye tracking system for two eye bones? Not sure on how it is defined in the metarig - is the bone where the target should be? That location can be based on where the eyes are and what direction they look.
		How to support arbitrary number of eyeballs with such setup on a character, but certain eyes looking at the same thing?
		I guess the riglet would be on the eye bones, and there is an "Eye Group" parameter which defines the name of the master target control, and which target controls will get parented to it.
		Procedural bone shape generation might be nice for the target master...
	Chain
		Recursive generation of STR layers as per Pablo's request, so we don't just have main and sub STR controls, but any number of nested layers(although we would probably never use more than 3, but then again, I thought we would never use more than 2, so)
		Spline IK like controls(the other two types) for bendy bones' handles.
	IK Chain
		Ability to have IK control at the end
	FK Chain
		Hinge and Root bone functionalities should be moved here, methinks.
	IK Fingers
		Would extend IK chain, but rotating the IK control would sort of bend the finger somehow, or something.
		Finger controls should go on a finger layer, and their UI needs to be figured out, so they don't clutter too much.
	IK/FK Snapping
		The arm pole control seems to land on the wrong side when snapping to IK. Probably should use the same pole finding logic that we use during generation. Could possibly even share code...!
		pole vector distance should be relative to the scale of the rig. I wonder how it works right now on very small or large rigs.
	Spine
		IMPORTANT: Should force chain segments to 1.
		IK/FK snapping? I'm guessing it's non-trivial, otherwise we would've done it. But it should be possible.
		Transformation constraints on FK-C bones (maybe make this optional)
			Their values would probably have to be dependent on the length of the bone. Ie, a long bone should slide more when it's rotated, compared to a short bone.
			Test if these can be overwritten by a cloud_bone rig.
	IK limbs
		feet control shouldn't be forced onto the floor, maybe based on an option, or use anklepivot bone, or whatever.
		ROLL-Foot.L shouldn't have its tail be offset in a flat forward direction. Instead, make it perpendicular to the knee, pointing towards the toe. (cross product of knee and toe bones' vectors?)
		AnklePivot should be renamed to HeelPivot in the script and the rigs...
		AnklePivot must be specified for footroll to work, but it has the old default.
		IK pole controls should have their roll re-calculated on some useful axis - This should be done by assigning a roll type to the BoneInfo, then calling Recalculate Roll on the appropriate bones in edit mode after generation.
		Some smartypants way of ensuring that the IK pole, when IK Pole Follow is enabled, follows the IK control on its roll axis, but not the other axes?
	Curve
		Would be nice to have the ability for symmetrical rigs(eg. Gabby's mouth) that not only names the bones symmetrically but also flips the handles on one side, so that X-Mirror posing works.
	Scissor limb rig possible? (limb with an extra bone to help elbow/knee deformation) - Can it work in FK?

	Bone
		Option to copy all children of the bone as well. This would let us be lazy for a while and attach entire manually rigged components to the generated rig, which would be a nice plan B if the face generation doesn't become a thing.
		Create Deform option should maybe only show up when the bone's Deform option is disabled... otherwise it's a bit error-prone.
	
	Manage bone rotation modes better - Currently we set everything to an arbitrary rotation mode, I think? We should probably copy the rotation mode from the metarig.

	When a driver or constraint targets a bone in the generated rig, and that bone's name is the same as the base bone in the metarig, and the rig is re-generated, the thing targetting it will be changed to the ORG- bone.
		This is because the rig generation starts by copying the metarig - at this stage, a bone with the base bone's name exists, so it gets picked up by those targets. Then this gets renamed to ORG-, and then a new bone with the base name is created.
		To avoid this, we should make it a point that no bone named the same as the original bone in the metarig should exist, and when such a bone is created, there should be a warning.
		For cloud_bone that solution doesn't quite work though, because a tweaking bone must be called the same on the base bone as it is on the generated rig.
			Maybe after the tweaking is done, the bone with the base name should be renamed to a temporary name, then the tweak bone renamed to the old name, deleted, and the other bone named back to what it was originally.

	Remove "Root Bone" generator parameter. There should always be a root bone.
	Generator parameter: Properties bone - If empty, we create a "Properties" bone (not Properties_IKFK), otherwise we can select a bone from the metarig's bones, and we'll create a bone in its place with its name as the Properties bone - or something like that.
	Generator parameter: Preserve bone layers - If enabled, we save the layers of every bone in the currently generated rig, before re-generating, and re-apply them.
		This should be grayed out/non-existent when rigify_target_rig==None.
	Generator operator: Symmetrize properties. Press to copy all rig elements' settings from the active bone's side to the opposite side.
	Generator parameter: Show Warnings
		When enabled, this will add a custom property to the rig data, to indicate to the UI script to add a new panel to the Properties Editor.
		This panel would be called CloudRig Log. It would read warnings and errors from the rig data, where it is written to from generation-time.

	Protected Layers should be copied from the metarig, unless no layers are protected on the metarig, in which case all layers should be protected.

	Improve bone group/layer system:
		Expose bone groupsin the UI as rig parameters.
		On first generation, if empty, these would get pre-filled with names of the bone groups that were created and used.
		If not empty, use the bone group that was selected. The bone group first has to exist on the metarig.

		Unified Selection Colors should have a factor, so the unified selection color can be blended with the original selection color... hehe.
		Store the layer UI layout data in the generated rig and use it in cloudrig.py.


	Implement a quadruped limb rig, similar to Autumn's hind leg.

	Face!

	Drivers for bone rotation types?
	Would be nice if rig samples and metarigs could be loaded from a .blend file instead of code-based generation bs. For metarigs it seems easy. For rig samples, it might be tricky because we have to juggle object modes.

Code quality:
	head and tail should have setters that force the setting to be a copy of the passed vector, so we can remove a bunch of .copy()'s and make the bone definition more foolproof.
	Rename things like "create", "setup" and "make" according to some logic... so far it was decided on a whim.
	BoneInfoContainer should be an iterable so we can do self.bone_infos instead of self.bone_infos.bones.
		.bone() function should be .ensure().
	We could use Rigify's neat constraint and driver adding logic, on top of what we already have. After all, we currently define constraints as just an arbitrary dictionary. Nothing is stopping us from passing that dictionary to the Rigify constraint maker function in rig_bones stage. Same idea with drivers?
		Instead of using Driver abstraction or (type, data) tuples, try storing drivers and constraints in a way where we can use rigify's driver and constraint applying functions to apply them.
	Instead of declaring every function to the preparation stage, there should be only one or a few prepare_bones function that calls the other functions and passes the neccessary information between them.
		(In a perfect world) Functions should only rely on calling `self` when referring to things that were created before prepare_bones stage, such as in initialize or in add_params.
	More and smaller functions:
		Functions should be split up into bone creating functions, and the functions for the loop that calls those bone creating functions. There shouldn't be two of these loops in one function. This is to make it easy to customize a rig by subclassing it, if needed.
